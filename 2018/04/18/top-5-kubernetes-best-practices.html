<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="panliang's blog."><meta name="keywords" content="Linux,Kubernetes,Docker,Microservices"><title>五大 Kubernetes 最佳实践【转载】 | 每天进步一点点……</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">五大 Kubernetes 最佳实践【转载】</h1><a id="logo" href="/.">每天进步一点点……</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">五大 Kubernetes 最佳实践【转载】</h1><div class="post-meta"><a href="/2018/04/18/top-5-kubernetes-best-practices.html#comments" class="comment-count"></a><p><span class="date">Apr 18, 2018</span><span><a href="/categories/Kubernetes/" class="category">Kubernetes</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>这篇演讲中的最佳实践来源于Sandeep和团队进行的关于在Kubernetes上以多种不同方式运行同一任务的讨论。他们把讨论的结果总结为一个最佳实践的清单。</p>
<p>这些最佳实践分为如下大类：</p>
<ol>
<li>构建容器</li>
<li>容器内部</li>
<li>部署</li>
<li>服务</li>
<li>应用架构</li>
</ol>
<h1 id="1、构建容器"><a href="#1、构建容器" class="headerlink" title="1、构建容器"></a>1、构建容器</h1><h2 id="不要信任任意的基础镜像"><a href="#不要信任任意的基础镜像" class="headerlink" title="不要信任任意的基础镜像"></a>不要信任任意的基础镜像</h2><p>不幸的是我们看到这个错误一直在发生， Pradeep说到。人们从DockerHub上随便拉一个某人做的基础镜像——这么做的理由仅仅是第一眼看过去这个镜像里面打包有他们需要的包——接着他们就把这个随便选的镜像推到生产环境中。</p>
<p>这么做是非常错误的：你使用的代码可能有很多漏洞，bug，错误版本，或者本身就被人有意把恶意软件打包进去——只是你不知道罢了。</p>
<p>要减轻这种风险，你可以使用静态分析工具，比如 CoreOS’ Clair 或者 Banyon Collector来对容器进行漏洞扫描。</p>
<h2 id="保持基础镜像尽量小"><a href="#保持基础镜像尽量小" class="headerlink" title="保持基础镜像尽量小"></a>保持基础镜像尽量小</h2><p>基于最简洁的可用基础镜像，然后基于它构建软件包，这样你就知道镜像里面到底有哪些东西。</p>
<p>越小的基础镜像开销也越小。你的应用可能只要5M， 但是如果你盲目的随便找一个镜像，比如Node.js， 它里面就包括了额外500M你根本要不到的库文件。</p>
<p>使用小镜像的其它优势有：</p>
<ul>
<li>快速构建</li>
<li>节约存储</li>
<li>拉取镜像更快</li>
<li>更小的潜在攻击面</li>
</ul>
<p><img src="http://dockone.io/uploads/article/20180411/5ae84e3774272f4ada16ab118eecf935.png" alt=""></p>
<h2 id="使用构建器模式"><a href="#使用构建器模式" class="headerlink" title="使用构建器模式"></a>使用构建器模式</h2><p>这种模式对静态语言特别有用，编译类似Go，C++或者Typescript for Node.js这些语言时。</p>
<p>在这种模式里你有一个构建容器，里面打包有编译器，依赖包，以及单元测试。 代码通过第一步之后产出构建的artifacts，这包括所有的文件，bundles等。然后再通过一个运行时容器，包括有监控和调试工具等。</p>
<p>到最后， 你的Dockerfile里面将会只包含你的基础镜像以及运行时环境容器。</p>
<p><img src="http://dockone.io/uploads/article/20180411/d39916404614fc32efab82d93dd276ef.png" alt=""></p>
<h1 id="2、容器内部"><a href="#2、容器内部" class="headerlink" title="2、容器内部"></a>2、容器内部</h1><h2 id="在容器的内部使用非root用户"><a href="#在容器的内部使用非root用户" class="headerlink" title="在容器的内部使用非root用户"></a>在容器的内部使用非root用户</h2><p>如果你在容器内使用root来更新包，那么你要把用户改成非root用户。</p>
<p>原因很简单，如果你的容器有后门被人利用了而且你还没把它的用户改成root之外的，那么一个简单的容器逃离将会导致你整个主机的root权限都被利用。但是如果你改成了非root用户，黑客就没那么容易得到root用户的权限了。</p>
<p>做为最佳实践，你要对你的基础设施加多层外壳保护。</p>
<p>在Kubernetes里面你可以通过设置安全上下文 <code>runAsNonRoot: true</code>来实现，这样会对整个集群cluster来生效。</p>
<h2 id="文件系统只读"><a href="#文件系统只读" class="headerlink" title="文件系统只读"></a>文件系统只读</h2><p>这一个最佳实践通过设置<code>readOnlyFileSystem: true</code>来实现。</p>
<h2 id="每个容器里面跑一个进程"><a href="#每个容器里面跑一个进程" class="headerlink" title="每个容器里面跑一个进程"></a>每个容器里面跑一个进程</h2><p>你当然可以在一个容器里面跑多个进程，但是推荐跑一个。这是由编排器的工作方式决定的。Kubernetes基于一个进程是否健康来管理容器。如果你在一个容器里面有20个进程，它如何知道容器是否健康呢？</p>
<h2 id="不要使用-Restart-on-Failure，-而应当-Crash-Cleanly"><a href="#不要使用-Restart-on-Failure，-而应当-Crash-Cleanly" class="headerlink" title="不要使用 Restart on Failure， 而应当 Crash Cleanly"></a>不要使用 Restart on Failure， 而应当 Crash Cleanly</h2><p>Kubernetes会重新启动失败的容器，因此你应该干净的做崩溃退出（给出一个错误码），这样Kubernetes就可以不用你的人工干预来成功重起了。</p>
<h2 id="日志打到标准输出和标准错误输出（stdout-amp-stderr"><a href="#日志打到标准输出和标准错误输出（stdout-amp-stderr" class="headerlink" title="日志打到标准输出和标准错误输出（stdout &amp; stderr)"></a>日志打到标准输出和标准错误输出（stdout &amp; stderr)</h2><p>Kubernetes缺省会监听这些管道，然后将输出传到日志服务上面去。在谷歌云上可以直接用StackDriver日志系统。</p>
<h1 id="3、部署"><a href="#3、部署" class="headerlink" title="3、部署"></a>3、部署</h1><h2 id="使用record选项来使回滚更方便"><a href="#使用record选项来使回滚更方便" class="headerlink" title="使用record选项来使回滚更方便"></a>使用record选项来使回滚更方便</h2><p>在引用一个yaml文件时，请使用–record选项：</p>
<pre><code>kubectl apply -f deployment.yaml --record
</code></pre><p>带了这个选项之后，每次升级的时都会保存到部署的日志里面，这样就提供了回滚一个变更的能力。</p>
<p><img src="http://dockone.io/uploads/article/20180411/16dccf91c7fbffec767492411c01263b.png" alt=""></p>
<h2 id="多使用描述性的标签label"><a href="#多使用描述性的标签label" class="headerlink" title="多使用描述性的标签label"></a>多使用描述性的标签label</h2><p>因为标签可以是任意的键值对，其表达力非常强。参考下图，以有名字为’Nifty‘的应用部署到四个容器里面。 通过选择BE标签你可以挑选出后端容器。</p>
<p><img src="http://dockone.io/uploads/article/20180411/da988d23d57e5a3dea3e6107ef8238b8.png" alt=""></p>
<h2 id="使用sidecar来做代理、监视器等"><a href="#使用sidecar来做代理、监视器等" class="headerlink" title="使用sidecar来做代理、监视器等"></a>使用sidecar来做代理、监视器等</h2><p>有时候你需要一组进程跟其它某个进程通讯。但是你又不希望把它们所有的都放进一个容器里面（前面提到的一个容器跑一个进程）， 你希望的是把相关的进程都放到一个Pod里面。</p>
<p>常见情况是你需要运行进程依赖的一个代理或者监视器，比如你的进程依赖一个数据库， 而你不希望把数据库的密码硬编码进每个容器里面，这个时会你可以把密码放到一个代理程序里面当作sidecar，由它来管理数据库连接：</p>
<p><img src="http://dockone.io/uploads/article/20180411/dbaab29fbb0f48f1b49fda82fc2615cd.png" alt=""></p>
<h2 id="不要使用sidecar来做启动引导"><a href="#不要使用sidecar来做启动引导" class="headerlink" title="不要使用sidecar来做启动引导"></a>不要使用sidecar来做启动引导</h2><p>尽管sidecar在处理集群内外的请求时非常有用，Sandeep不推荐使用它做启动。再过去，引导启动（bootstraping）是唯一选项，但是现在Kubernetes有了“init 容器”。</p>
<p>当容器里面的一个进程依赖于其它的一个微服务时， 你可以使用init容器来等到进程启动以后再启动你的容器。这可以避免当进程和微服务不同步时产生的很多错误。</p>
<p>基本原则就是： 使用sidecar来处理总是发生的事件，而用init容器来处理一次性的事件。</p>
<h2 id="不要使用：latest或者无标签"><a href="#不要使用：latest或者无标签" class="headerlink" title="不要使用：latest或者无标签"></a>不要使用：latest或者无标签</h2><p>这个原则是很明显的而且大家基本都这么在用。如果你不给你的容器加标签，那么它会总是拉最新的，这个“最新的”并不能保证包括你认为它应该有的那些更新。</p>
<h2 id="善用readiness、liveness探针"><a href="#善用readiness、liveness探针" class="headerlink" title="善用readiness、liveness探针"></a>善用readiness、liveness探针</h2><p>使用探针可以让Kubernetes知道节点是否正常，以此决定是否把流量发给它。缺省情况下Kubernetes检查进程是否在运行。但是通过使用探针， 你可以在缺省行为下加上你自己的逻辑。</p>
<p><img src="http://dockone.io/uploads/article/20180411/a7b33d28e521896f6e05b83f9ef775c2.png" alt=""></p>
<h1 id="4、服务"><a href="#4、服务" class="headerlink" title="4、服务"></a>4、服务</h1><h2 id="不要使用type-Loadbalancer"><a href="#不要使用type-Loadbalancer" class="headerlink" title="不要使用type: Loadbalancer"></a>不要使用type: Loadbalancer</h2><p>每次你在部署文件里面加一个公有云提供商的loadbalancer（负载均衡器）的时候，它都会创建一个。 它确实是高可用，高速度，但是它也有经济成本。</p>
<p>使用Ingress来代替，同样可以实现通过一个end point来负载均衡多个服务。这种方式不但更简单，而且更经济。当然这个策略只有你提供http和web服务时有用，对于普通的TCP/UDP应用就没用了。</p>
<p><img src="http://dockone.io/uploads/article/20180411/43d7072b406f4369e71668d6b566fb4e.png" alt=""></p>
<h2 id="Type-Nodeport可能已经够用了"><a href="#Type-Nodeport可能已经够用了" class="headerlink" title="Type: Nodeport可能已经够用了"></a>Type: Nodeport可能已经够用了</h2><p>这个更多是个人喜好，并不是所有人都推荐。NodePort把你的应用通过一个VM的特定端口暴露到外网上。 问题就是它没有像负载均衡器那样有高可用。比如极端情况，VM挂了你的服务也挂了。</p>
<h2 id="使用静态IP，-它们免费！"><a href="#使用静态IP，-它们免费！" class="headerlink" title="使用静态IP， 它们免费！"></a>使用静态IP， 它们免费！</h2><p>在谷歌云上很简单，只需要为你的ingress来创建全局IP。类似的对你的负载均衡器可以使用Regional IP。这样当你的服务down了之后你不必担心IP会变。</p>
<h2 id="将外部服务映射到内部"><a href="#将外部服务映射到内部" class="headerlink" title="将外部服务映射到内部"></a>将外部服务映射到内部</h2><p>Kubernetes提供的这个功能不是所有人都知道。如果您需要群集外部的服务，您可以做的是使用ExternalName类型的服务。这样你就可以通过名字来调用这个服务，Kubernetes manager会把请求传递给它，就好像它在集群之中一样。Kubernetes对待这个服务就好像它在同一个内网里面，即使实际上它不在。</p>
<h1 id="5、应用架构"><a href="#5、应用架构" class="headerlink" title="5、应用架构"></a>5、应用架构</h1><h2 id="使用Helm-Charts"><a href="#使用Helm-Charts" class="headerlink" title="使用Helm Charts"></a>使用Helm Charts</h2><p>Helm基本上就是打包Kubernetes应用配置的仓库。如果你要部署一个MongoDB， 存在一个预先配置好的Helm chart，包括了它所有的依赖，你可以十分容易的把它部署到集群中。</p>
<p>很多流行的软件/组件都有写好了的Helm charts， 你可以直接用，省掉大量的时间和精力。</p>
<h2 id="所有下游的依赖是不可靠的"><a href="#所有下游的依赖是不可靠的" class="headerlink" title="所有下游的依赖是不可靠的"></a>所有下游的依赖是不可靠的</h2><p>你的应用应该有逻辑和错误信息负责审计你不能控制的所有依赖。Sandeep建议说你可以使用Istio或者Linkerd这样的服务网格来做下游管理。</p>
<h2 id="使用Weave-Cloud"><a href="#使用Weave-Cloud" class="headerlink" title="使用Weave Cloud"></a>使用Weave Cloud</h2><p>集群是很难可视化管理的。 使用Weave Cloud可以帮你监视集群内的情况和跟踪依赖。</p>
<h2 id="确保你的微服务不要太“微小”"><a href="#确保你的微服务不要太“微小”" class="headerlink" title="确保你的微服务不要太“微小”"></a>确保你的微服务不要太“微小”</h2><p>你需要的是逻辑组件，而不是每个单独的功能/函数都变成一个微服务。</p>
<h2 id="使用Namespace来分离集群"><a href="#使用Namespace来分离集群" class="headerlink" title="使用Namespace来分离集群"></a>使用Namespace来分离集群</h2><p>例如， 你可以在同一个集群里面创建prod、dev、test这样不同的名字空间，同时可以对不同的名字空间分配资源， 这样万一某个进程有问题也不会用尽所有的集群资源。</p>
<h2 id="基于角色的访问控制RBAC"><a href="#基于角色的访问控制RBAC" class="headerlink" title="基于角色的访问控制RBAC"></a>基于角色的访问控制RBAC</h2><p>实施时当的访问控制来限制访问量， 这也是最佳的安全实践。</p>
<h1 id="从运行Weave-Cloud生产环境学到的教训"><a href="#从运行Weave-Cloud生产环境学到的教训" class="headerlink" title="从运行Weave Cloud生产环境学到的教训"></a>从运行Weave Cloud生产环境学到的教训</h1><p>接下来Jordan Pellizzari做了一个演讲，题目是在过去两年我们在Kubernetes上开发运行Weave Cloud学到的经验。 我们当前运行在AWS EC2上， 总共有72个Kubernetes部署运行在13个主机和150个容器里面。我们所有的持续性存储保存在S3，DynamoDB或者RDS里面， 我们并不在容器里面保存状态信息。 关于我们如何搭建基础设施的细节可以参看<a href="https://www.weave.works/technologies/weaveworks-on-aws/" target="_blank" rel="noopener">这篇文档</a>。</p>
<h2 id="挑战1：对基础设施做版本控制"><a href="#挑战1：对基础设施做版本控制" class="headerlink" title="挑战1：对基础设施做版本控制"></a>挑战1：对基础设施做版本控制</h2><p>在Weaveworks我们把所有的基础架构保存在Git中， 如果我们要对基础设施做变更，要像代码一样提Pull request。我们把这称为GitOps，也写了多篇博文。你可以从这篇读起： GitOps - Pull Request支撑的运维。</p>
<p>在Weave， 所有的Terraform脚本，Ansible以及Kubernetes YAML文件都被保存在Git里面做版本控制。</p>
<p>把基础架构放在Git里面是一个最佳实践，这有多个原因：</p>
<ul>
<li>发布可以很方便的回滚</li>
<li>对谁做了什么修改有追踪审计</li>
<li>灾难恢复相当简单</li>
</ul>
<p><strong>问题： 当生产与版本控制不一致时该怎么办？</strong></p>
<p>除了把所有内容保存在Git中之外，我们也有一个流程会检查生产集群中运行的状态与版本控制中的内容差异。如果检查到有不同，就会给我们的Slack频道发一个报警。</p>
<p>我们使用一个叫<a href="https://github.com/weaveworks/kubediff" target="_blank" rel="noopener">Kube-Diff</a>的开源工具来检查不同。</p>
<h2 id="挑战2：自动化的持续交付"><a href="#挑战2：自动化的持续交付" class="headerlink" title="挑战2：自动化的持续交付"></a>挑战2：自动化的持续交付</h2><p>自动化你的CI/CD流水线，避免手工的Kubernetes部署。因为我们一天内做多次部署，这种方式节约了团队的时间也避免了手工容易发生错误的步骤。在Weaveworks，开发人员只需要做一个Git push，然后Weave Cloud会做以下的事情：</p>
<ul>
<li>打过标签的代码通过CircleCI的测试然后构建一个新的容器镜像，推送这个新的镜像到仓库中。</li>
<li>Weave Cloud的“Deploy Automator‘检测到新镜像，从库中拉取新镜像然后在配置库里面更新对应的YAML文件。</li>
<li>Deploy Synchronizer会检测到集群需要更改in了，然后它会从配置库里面拉更新的配置清单，最后将新的镜像部署到集群中。</li>
</ul>
<p><strong>GitOps流水线</strong></p>
<p><img src="http://dockone.io/uploads/article/20180411/1c8628004bbaf147edf54605108d3784.png" alt=""></p>
<p>这里有一篇<a href="https://www.weave.works/blog/the-gitops-pipeline" target="_blank" rel="noopener">稍长的文章</a>，我们认为的构建自动化CI/CD流水线的最佳实践都在里面描述了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Sandeep Dinesh做了一个关于创建、部署、运行应用到Kubernetes里面的五个最佳实践的深度分享。随后Jordan Pellizzari做了Weave如何在kubernetes中管理SaaS产品Weave Cloud和经验教训的分享。</p>
<p><strong>相关链接：</strong></p>
<ol>
<li><a href="https://www.meetup.com/pro/weave/" target="_blank" rel="noopener">https://www.meetup.com/pro/weave/</a></li>
<li><a href="https://github.com/coreos/clair" target="_blank" rel="noopener">https://github.com/coreos/clair</a></li>
<li><a href="https://github.com/banyanops/collector" target="_blank" rel="noopener">https://github.com/banyanops/collector</a></li>
<li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/security-context/</a></li>
<li><a href="https://www.weave.works/features/troubleshooting-dashboard/" target="_blank" rel="noopener">https://www.weave.works/features/troubleshooting-dashboard/</a></li>
<li><a href="https://www.weave.works/technologies/weaveworks-on-aws/" target="_blank" rel="noopener">https://www.weave.works/technologies/weaveworks-on-aws/</a></li>
<li><a href="https://www.weave.works/blog/gitops-operations-by-pull-request" target="_blank" rel="noopener">https://www.weave.works/blog/gitops-operations-by-pull-request</a></li>
<li><a href="https://github.com/weaveworks/kubediff" target="_blank" rel="noopener">https://github.com/weaveworks/kubediff</a></li>
<li><a href="https://www.weave.works/blog/the-gitops-pipeline" target="_blank" rel="noopener">https://www.weave.works/blog/the-gitops-pipeline</a></li>
</ol>
<p>原文链接：<a href="https://dzone.com/articles/top-5-kubernetes-best-practices-from-sandeep-dines" target="_blank" rel="noopener">Top 5 Kubernetes Best Practices From Sandeep Dinesh (Google)</a></p>
<p><a href="https://v.qq.com/x/page/n0627q2l72y.html" target="_blank" rel="noopener"><strong>完整视频</strong></a></p>
</div><div class="tags"><a href="/tags/Kubernetes/">Kubernetes</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/05/07/troubleshooting-index.html" class="pre">Kubernetes 排错指南：开篇【转载】</a><a href="/2018/04/02/kubernetes-19-conflict-with-centos7.html" class="next">Kubernetes 1.9 与 CentOS 7 内核兼容问题【转载】</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1、构建容器"><span class="toc-text">1、构建容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#不要信任任意的基础镜像"><span class="toc-text">不要信任任意的基础镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保持基础镜像尽量小"><span class="toc-text">保持基础镜像尽量小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用构建器模式"><span class="toc-text">使用构建器模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2、容器内部"><span class="toc-text">2、容器内部</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在容器的内部使用非root用户"><span class="toc-text">在容器的内部使用非root用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统只读"><span class="toc-text">文件系统只读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#每个容器里面跑一个进程"><span class="toc-text">每个容器里面跑一个进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要使用-Restart-on-Failure，-而应当-Crash-Cleanly"><span class="toc-text">不要使用 Restart on Failure， 而应当 Crash Cleanly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日志打到标准输出和标准错误输出（stdout-amp-stderr"><span class="toc-text">日志打到标准输出和标准错误输出（stdout &amp; stderr)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3、部署"><span class="toc-text">3、部署</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用record选项来使回滚更方便"><span class="toc-text">使用record选项来使回滚更方便</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多使用描述性的标签label"><span class="toc-text">多使用描述性的标签label</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用sidecar来做代理、监视器等"><span class="toc-text">使用sidecar来做代理、监视器等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要使用sidecar来做启动引导"><span class="toc-text">不要使用sidecar来做启动引导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不要使用：latest或者无标签"><span class="toc-text">不要使用：latest或者无标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#善用readiness、liveness探针"><span class="toc-text">善用readiness、liveness探针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4、服务"><span class="toc-text">4、服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#不要使用type-Loadbalancer"><span class="toc-text">不要使用type: Loadbalancer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Nodeport可能已经够用了"><span class="toc-text">Type: Nodeport可能已经够用了</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用静态IP，-它们免费！"><span class="toc-text">使用静态IP， 它们免费！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将外部服务映射到内部"><span class="toc-text">将外部服务映射到内部</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5、应用架构"><span class="toc-text">5、应用架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Helm-Charts"><span class="toc-text">使用Helm Charts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#所有下游的依赖是不可靠的"><span class="toc-text">所有下游的依赖是不可靠的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Weave-Cloud"><span class="toc-text">使用Weave Cloud</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确保你的微服务不要太“微小”"><span class="toc-text">确保你的微服务不要太“微小”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Namespace来分离集群"><span class="toc-text">使用Namespace来分离集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于角色的访问控制RBAC"><span class="toc-text">基于角色的访问控制RBAC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从运行Weave-Cloud生产环境学到的教训"><span class="toc-text">从运行Weave Cloud生产环境学到的教训</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#挑战1：对基础设施做版本控制"><span class="toc-text">挑战1：对基础设施做版本控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#挑战2：自动化的持续交付"><span class="toc-text">挑战2：自动化的持续交付</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/12/comparison-between-calico-and-flannel.html">calico与flannel对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/troubleshooting-pod.html">Kubernetes 排错指南：POD【转载】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/troubleshooting-cluster.html">Kubernetes 排错指南：集群【转载】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/troubleshooting-index.html">Kubernetes 排错指南：开篇【转载】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/top-5-kubernetes-best-practices.html">五大 Kubernetes 最佳实践【转载】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/02/kubernetes-19-conflict-with-centos7.html">Kubernetes 1.9 与 CentOS 7 内核兼容问题【转载】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/01/performance-tuning-overview.html">性能调优概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/31/simplifying-microservices-with-istio-in-kubernetes-3.html">使用Istio简化微服务系列三：如何才能做“金丝雀部署”，并通过Istio增加流量？【转载】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/31/simplifying-microservices-with-istio-in-kubernetes-2.html">使用Istio简化微服务系列二：如何通过HTTPS与外部服务进行通信？【转载】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/31/simplifying-microservices-with-istio-in-kubernetes-1.html">使用Istio简化微服务系列一：如何用Isito解决Spring Cloud Netflix部署微服务的挑战?【转载】</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jenkins/">Jenkins</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kubernetes/">Kubernetes</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a><span class="category-list-count">11</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/亲和性/" style="font-size: 15px;">亲和性</a> <a href="/tags/微服务入门系列/" style="font-size: 15px;">微服务入门系列</a> <a href="/tags/Pipeline/" style="font-size: 15px;">Pipeline</a> <a href="/tags/微服务拆分/" style="font-size: 15px;">微服务拆分</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/Kubernetes/" style="font-size: 15px;">Kubernetes</a> <a href="/tags/Dubbo-Service-Mesh-微服务-ZooKeeper/" style="font-size: 15px;">Dubbo,Service Mesh,微服务,ZooKeeper</a> <a href="/tags/性能调优/" style="font-size: 15px;">性能调优</a> <a href="/tags/Istio简化微服务系列/" style="font-size: 15px;">Istio简化微服务系列</a> <a href="/tags/Spring-Cloud/" style="font-size: 15px;">Spring Cloud</a> <a href="/tags/Kubernetes-排错指南/" style="font-size: 15px;">Kubernetes 排错指南</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Cloudpanl.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?8c06a0cc670571138e4a33bce0d3167a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>